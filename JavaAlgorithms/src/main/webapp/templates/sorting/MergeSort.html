<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Java Sorting Algorithms</title>
    <!-- Bootstrap - CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Bootstrap Icons - CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- Charts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>

    <!-- Color Mod -->
    <script src="/JavaAlgorithms/resources/js/color-mode.js"></script>

    <!-- amChart -->
    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/hierarchy.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

    <!-- Favicons : 웹 아이콘 설정 -->
    <link rel="apple-touch-icon" href="/JavaAlgorithms/resources/icon/java-touch-icon.png" sizes="180x180">
    <link rel="icon" href="/JavaAlgorithms/resources/icon/java-32x32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="/JavaAlgorithms/resources/icon/java-16x16.png" sizes="16x16" type="image/png">
    <link rel="manifest" href="https://getbootstrap.kr/docs/5.3/assets/img/favicons/manifest.json">
    <link rel="mask-icon" href="https://getbootstrap.kr/docs/5.3/assets/img/favicons/safari-pinned-tab.svg"
        color="#712cf9">
    <link rel="icon" href="/JavaAlgorithms/resources/icon/java.ico">
    <meta name="theme-color" content="#712cf9">
    <link href="/JavaAlgorithms/resources/css/bootstrap-icons.min.css" rel="stylesheet">
    <link href="/JavaAlgorithms/resources/css/dashboard.css" rel="stylesheet">

    <!-- Prism CSS -->
    <link href="/JavaAlgorithms/resources/css/prism.css" rel="stylesheet" type="text/css">

    <!-- Custom CSS -->
    <link href="/JavaAlgorithms/resources/css/style.css" rel="stylesheet" type="text/css">
</head>

<body>
    <div data-include-path="/JavaAlgorithms/templates/layouts/header.html"></div>
    <!-- Main DOM -->
    <div class="container-fluid">
        <div class="row">
            <div data-include-path="/JavaAlgorithms/templates/layouts/nav.html"></div>
            <!-- MainBoard -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-mds4" id="dashboard">


                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1>Merge Sort</h1>
                </div>
                <p><strong>Merge Sort</strong> is a sorting algorithm that follows the divide and conquer strategy. It
                    divides the input array into two halves, recursively sorts the halves, and then merges them to
                    produce a sorted array.</p>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>History</h2>
                </div>
                <p>Merge Sort was invented by John von Neumann in 1945. It is widely used for sorting large datasets
                    efficiently. Merge Sort is considered one of the most efficient sorting algorithms in terms of time
                    complexity.</p>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Working Principle</h2>
                </div>
                <p>Consider an array to be sorted: <code>[5, 3, 8, 4, 2]</code>.</p>

                <h5>Step.1</h5>
                <ul>
                    <li><code>[5, 3, 8, 4, 2]</code> (Initial array)</li>
                    <li>Divide the array into two halves: <code>[5, 3]</code> and <code>[8, 4, 2]</code></li>
                    <li>Recursively sort each half</li>
                </ul>

                <h5>Step.2</h5>
                <ul>
                    <li><code>[3, 5]</code> and <code>[2, 4, 8]</code> (Sorted halves from step 1)</li>
                    <li>Merge the sorted halves into a single sorted array</li>
                    <li>Result: <code>[2, 3, 4, 5, 8]</code></li>
                </ul>

                <h5>Result</h5>
                <p><code>[2, 3, 4, 5, 8]</code> (sorted)</p>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Time Complexity</h2>
                </div>
                <ul>
                    <li><strong>Time complexity:</strong> \(O(n \log n)\)</li>
                </ul>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Summary</h2>
                </div>
                <p>Merge Sort is a highly efficient sorting algorithm with a time complexity of \(O(n \log n)\). It is
                    widely used in practice for sorting large datasets. This page has provided an explanation of Merge
                    Sort, including its definition, working principle, time complexity, and history. Understanding Merge
                    Sort is essential for anyone dealing with sorting algorithms.</p>


                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Java code</h2>
                </div>

                <div class="collapse show" id="collapse-code">
                    <pre class="line-numbers">
        <code class="language-java">public void sort() {
            int[] list = super.getList();
            super.setList(divide(list));
        }
        
        private int[] divide(int[] list) {
            if (list.length > 1) {
                return merge(divide(Arrays.copyOfRange(list, 0, list.length / 2)),
                        divide(Arrays.copyOfRange(list, list.length / 2, list.length)));
            } else
                return list;
        };
        
        private int[] merge(int[] left, int[] right) {
            int[] result = new int[left.length + right.length];
            int j = 0;
            int cnt = 0;
        
            for (int i = 0; i < left.length; i++) {
                while (j < right.length && left[i] > right[j]) {
                    result[cnt++] = right[j++];
                }
                result[cnt++] = left[i];
            }
        
            while (j < right.length) {
                result[cnt++] = right[j++];
            }
            return result;
        }</code>
                </pre>
                </div>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2 id="chart_area">Visualization</h2>
                    <i class="bi bi-gear-fill" data-bs-toggle="collapse" href="#collapse-setting" role="button"
                        aria-expanded="false" aria-controls="collapse"></i>
                </div>
                <div class="collapse" id="collapse-setting">
                    <div class="card card-body">
                        <div data-include-path="/JavaAlgorithms/templates/sorting/ArraySetting.html">
                        </div>

                        <input type="range" class="form-range" min="100" max="2000" value="500" id="speed">
                    </div>
                </div>

                <div class="collapse show" id="collapse-chart">
                    <!-- Bar Chart -->
                    <div class="d-flex flex-column justify-content-center">
                        <canvas class="my-4" id="barChart"
                            style="display: block; box-sizing: border-box; height: 445px; width: 1056px;"></canvas>
                        <div class="row mx-auto p-2">
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="bar_startBtn" onclick="bar_start()">
                                    <i class="bi bi-play-fill"></i>
                                </button>
                            </div>
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="bar_pauseBtn" onclick="bar_pause()">
                                    <i class="bi bi-pause-fill"></i>
                                </button>
                            </div>
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="bar_resetBtn" onclick="bar_reset()">
                                    <i class="bi bi-arrow-clockwise"></i>
                                </button>

                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    <!-- Prism JS -->
    <script src="/JavaAlgorithms/resources/js/prism.js"></script>

    <script type="text/javascript" src="/JavaAlgorithms/resources/js/includeHTML.js"></script>
    <!-- Jquery -->
    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
    <!-- Custom JS -->
    <script type="text/javascript" src="/JavaAlgorithms/resources/js/global.js"></script>
    <script type="text/javascript" src="/JavaAlgorithms/resources/js/sorting.js"></script>
    <script>
        function bar_start() {
            now = new Date().getTime();
            var data = [...myBarChart.chart.data.datasets[0].data];
            myBarChart.running = true;

            divide(data, 0, data.length - 1);
        }

        function divide(data, min, max) {
            if (max - min == 0) return;
            else if (max - min == 1) {
                if (data[min] > data[max])
                    myBarChart.swap(data, min, max);
            }
            else {
                var mid = Math.floor((min + max) / 2);
                divide(data, min, mid);
                divide(data, mid + 1, max);
                merge(data, min, max, mid);
            }
        }
        function merge(data, min, max, mid) {
            var i = min;
            while (i <= mid) {
                if (data[i] > data[mid + 1]) {
                    myBarChart.swap(data, i, mid + 1);
                    for (var j = mid + 1; j < max; j++) {
                        if (data[j] > data[j + 1]) {
                            myBarChart.swap(data, j, j + 1);
                        }
                    }
                }
                i++;
            }
        }
    </script>
    <!-- Chart js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.0.1/chart.umd.js"
        integrity="sha512-7DgGWBKHddtgZ9Cgu8aGfJXvgcVv4SWSESomRtghob4k4orCBUTSRQ4s5SaC2Rz+OptMqNk0aHHsaUBk6fzIXw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Bootstrap - JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
</body>

</html>
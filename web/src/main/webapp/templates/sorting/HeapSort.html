<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Java Sorting Algorithms</title>
    <!-- Bootstrap - CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Bootstrap Icons - CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- Charts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>

    <!-- Color Mod -->
    <script src="/JavaAlgorithms/resources/js/color-mode.js"></script>

    <!-- amChart -->
    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/hierarchy.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

    <!-- Favicons : 웹 아이콘 설정 -->
    <link rel="apple-touch-icon" href="/JavaAlgorithms/resources/icon/java-touch-icon.png" sizes="180x180">
    <link rel="icon" href="/JavaAlgorithms/resources/icon/java-32x32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="/JavaAlgorithms/resources/icon/java-16x16.png" sizes="16x16" type="image/png">
    <link rel="manifest" href="https://getbootstrap.kr/docs/5.3/assets/img/favicons/manifest.json">
    <link rel="mask-icon" href="https://getbootstrap.kr/docs/5.3/assets/img/favicons/safari-pinned-tab.svg"
        color="#712cf9">
    <link rel="icon" href="/JavaAlgorithms/resources/icon/java.ico">
    <meta name="theme-color" content="#712cf9">
    <link href="/JavaAlgorithms/resources/css/bootstrap-icons.min.css" rel="stylesheet">
    <link href="/JavaAlgorithms/resources/css/dashboard.css" rel="stylesheet">

    <!-- Prism CSS -->
    <link href="/JavaAlgorithms/resources/css/prism.css" rel="stylesheet" type="text/css">

    <!-- Custom CSS -->
    <link href="/JavaAlgorithms/resources/css/style.css" rel="stylesheet" type="text/css">
</head>

<body>
    <div data-include-path="/JavaAlgorithms/templates/layouts/header.html"></div>
    <!-- Main DOM -->
    <div class="container-fluid">
        <div class="row">
            <div data-include-path="/JavaAlgorithms/templates/layouts/nav.html"></div>
            <!-- MainBoard -->
            <main class="col-md-9 ms-sm-auto col-lg-10 px-mds4" id="dashboard">
                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1>Heap Sort</h1>
                </div>
                <p><strong>Heap Sort</strong> is a comparison-based sorting algorithm that uses a binary heap data
                    structure. It first builds a max-heap from the input array and then repeatedly extracts the maximum
                    element from the heap and rebuilds the heap until the array is sorted.</p>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>History</h2>
                </div>
                <p>Heap Sort was invented by J. W. J. Williams in 1964. It was first introduced as part of the heapsort
                    algorithm, which also included the heap construction process. Heap Sort has since become a widely
                    used sorting algorithm due to its efficiency and simplicity.</p>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Working Principle</h2>
                </div>
                <p>Consider an array to be sorted: <code>[5, 3, 8, 4, 2]</code>.</p>

                <h5>Step.1</h5>
                <ul>
                    <li><code>[5, 3, 8, 4, 2]</code> (Initial array)</li>
                    <li>Build a max-heap from the array</li>
                    <li>Extract the maximum element (8) and move it to the end</li>
                </ul>

                <h5>Step.2</h5>
                <ul>
                    <li><code>[3, 2, 5, 4]</code> (Heap after removing the maximum element)</li>
                    <li>Repeat the heapify process on the remaining elements</li>
                    <li>Extract the maximum element (5) and move it to the end</li>
                </ul>

                <h5>Step.3</h5>
                <ul>
                    <li><code>[2, 3, 4]</code> (Heap after removing the maximum element)</li>
                    <li>Repeat the heapify process on the remaining elements</li>
                    <li>Extract the maximum element (4) and move it to the end</li>
                </ul>

                <h5>Step.4</h5>
                <ul>
                    <li><code>[2, 3]</code> (Heap after removing the maximum element)</li>
                    <li>Repeat the heapify process on the remaining elements</li>
                    <li>Extract the maximum element (3) and move it to the end</li>
                </ul>

                <h5>Step.5</h5>
                <ul>
                    <li><code>[2]</code> (Heap after removing the maximum element)</li>
                    <li>Repeat the heapify process on the remaining elements</li>
                    <li>Extract the maximum element (2) and move it to the end</li>
                </ul>

                <h5>Result</h5>
                <p><code>[2, 3, 4, 5, 8]</code> (sorted)</p>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Time Complexity</h2>
                </div>
                <ul>
                    <li><strong>Time complexity:</strong> \(O(n \log n)\) in all cases</li>
                </ul>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2>Summary</h2>
                </div>
                <p>Heap Sort is a comparison-based sorting algorithm with a time complexity of \(O(n \log n)\) in all
                    cases. It is widely used for sorting large datasets due to its efficiency and stability. This page
                    has provided an explanation of Heap Sort, including its definition, working principle, time
                    complexity, and history.</p>


                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1>Java Code</h1>
                </div>

                <div class="collapse show" id="collapse-code">
                    <pre class="line-numbers">
        <code class="language-java">import java.util.PriorityQueue;

        public void sort() {
            int[] list = super.getList();
    
            PriorityQueue<Integer> heap = new PriorityQueue<Integer>();
    
            for (int i = 0; i < list.length; i++) {
                heap.add(list[i]);
            }
    
            for (int i = 0; i < list.length; i++) {
                list[i] = heap.poll();
            }    
        }</code>
                    </pre>

                    <pre class="line-numbers">
        <code class="language-java">public void sort() {
            int[] list = super.getList();
    
            for (int i = list.length - 1; i >= 0; i--) {
                heapify(list, i);
                if (list[0] > list[i]) {
                    swap(0, i);
                }
            }
        }</code>
                    </pre>

                    <pre class="line-numbers">
        <code class="language-java">public void heapify(int[] list, int i) {
            int index = (i / 2) - 1;
            while (index >= 0) {
                int left = index * 2 + 1;
                int right = index * 2 + 2;
    
                if (list[left] >= list[right] && list[index] < list[left]) {
                    swap(index, left);
                } else if (list[right] > list[left] && list[index] < list[right]) {
                    swap(index, right);
                }
                index--;
            }
        }</code>
                    </pre>
                </div>

                <div
                    class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h2 id="chart_area">Visualization</h2>
                    <i class="bi bi-gear-fill" data-bs-toggle="collapse" href="#collapse-setting" role="button"
                        aria-expanded="false" aria-controls="collapse"></i>
                </div>
                <div class="collapse" id="collapse-setting">
                    <div class="card card-body">
                        <div data-include-path="/JavaAlgorithms/templates/sorting/ArraySetting.html">
                        </div>

                        <input type="range" class="form-range" min="100" max="2000" value="500" id="speed">
                    </div>
                </div>

                <div class="collapse show" id="collapse-chart">
                    <!-- Bar Chart -->
                    <div class="d-flex flex-column justify-content-center">
                        <canvas class="my-4" id="barChart"
                            style="display: block; box-sizing: border-box; height: 445px; width: 1056px;"></canvas>
                        <div class="row mx-auto p-2">
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="bar_startBtn" onclick="bar_start()">
                                    <i class="bi bi-play-fill"></i>
                                </button>
                            </div>
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="bar_pauseBtn" onclick="bar_pause()">
                                    <i class="bi bi-pause-fill"></i>
                                </button>
                            </div>
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="bar_resetBtn" onclick="bar_reset()">
                                    <i class="bi bi-arrow-clockwise"></i>
                                </button>

                            </div>
                        </div>
                    </div>
                </div>

                <div class="collapse show" id="collapse-chart">
                    <!-- Tree Chart -->
                    <div class="d-flex flex-column justify-content-center">
                        <!-- HTML -->
                        <div id="treeChart" style="display: block; width: 100%; height: 500px;"></div>

                        <div class="card card-body">
                            <div id="treeList"></div>
                        </div>

                        <div class="row mx-auto p-2">
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="BarSortingBtn" onclick="tree_start()">
                                    <i class="bi bi-play-fill"></i>
                                </button>
                            </div>
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="pauseBtn" onclick="tree_pause()">
                                    <i class="bi bi-pause-fill"></i>
                                </button>
                            </div>
                            <div class="col">
                                <button type="button" class="btn btn-primary" id="resetBtn" onclick="tree_reset()">
                                    <i class="bi bi-arrow-clockwise"></i>
                                </button>

                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    <!-- Prism JS -->
    <script src="/JavaAlgorithms/resources/js/prism.js"></script>

    <script type="text/javascript" src="/JavaAlgorithms/resources/js/includeHTML.js"></script>
    <!-- Jquery -->
    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
    <!-- Custom JS -->
    <script type="text/javascript" src="/JavaAlgorithms/resources/js/global.js"></script>
    <script type="text/javascript" src="/JavaAlgorithms/resources/js/sorting.js"></script>
    <script>
        function bar_start() {
            now = new Date().getTime();
            var data = [...myBarChart.chart.data.datasets[0].data];
            myBarChart.running = true;

            for (let i = data.length - 1; i >= 0; i--) {
                bar_heapify(data, i)
                if (data[0] > data[i]) {
                    myBarChart.swap(data, 0, i);
                }
            }
        }
        function bar_heapify(data, i) {
            let index = parseInt(i / 2) - 1;
            while (index >= 0) {
                const left = index * 2 + 1;
                const right = index * 2 + 2;

                if (data[left] >= data[right] && data[index] < data[left]) {
                    myBarChart.swap(data, index, left);
                } else if (data[right] > data[left] && data[index] < data[right]) {
                    myBarChart.swap(data, index, right);
                }
                index--;
            }
        }


        function tree_start() {
            now = new Date().getTime();
            var data = [...firstArray];
            myTreeChart.running = true;

            /* 최대 힙 구현*/
            var tree = [];
            for (var i = 0; i < data.length; i++) {
                tree_add(tree, i, data[i]);
            }

            for (var i = data.length - 1; i >= 0; i--) {
                tree_pop(tree, i);
                tree_heapify(tree, i);
            }
        }

        function tree_add(tree, index, value) {
            var data = {id: index, name: value, fill: '#333d4d'};
            if (tree.length == 0) {
                tree.push(data);
            } else {
                var parents = myTreeChart.getNode(tree, Math.floor((index - 1) / 2));
                if (index % 2 == 1) {
                    parents.children = [];
                }
                parents.children.push(data);
            }
            myTreeChart.update(JSON.parse(JSON.stringify(tree)));
            myTreeChart.removeListChild();

            while (index > 0) {
                var node = myTreeChart.getNode(tree, index);
                var parents = myTreeChart.getNode(tree, (Math.floor((index - 1) / 2)));
                if (parents.name > node.name) {
                    break;
                } else {
                    var temp = node.name;
                    node.name = parents.name;
                    parents.name = temp;
                    myTreeChart.update(JSON.parse(JSON.stringify(tree)));
                    index = parents.id;
                }
            }
        }

        function tree_pop(tree, index) {
            myTreeChart.addListChild(tree[0].name);
            if (index > 0) {
                tree[0].name = myTreeChart.pop(tree, index);
            } else {
                tree = [];
            }
            myTreeChart.update(JSON.parse(JSON.stringify(tree)));
        }


        function tree_heapify(tree) {
            var temp = tree[0]
            while ('children' in temp) {
                if (temp.children.length == 1) {
                    if (temp.children[0].name > temp.name) {
                        var value = temp.name;
                        temp.name = temp.children[0].name;
                        temp.children[0].name = value;
                        myTreeChart.update(JSON.parse(JSON.stringify(tree)));
                    }
                    temp = temp.children[0]
                } else {
                    if (temp.name > temp.children[0].name && temp.name > temp.children[1].name) {
                        break;
                    } else {

                        var biggerChildren = temp.children[0].name > temp.children[1].name ? temp.children[0] : temp.children[1];
                        var value = temp.name;
                        temp.name = biggerChildren.name;
                        biggerChildren.name = value;
                        myTreeChart.update(JSON.parse(JSON.stringify(tree)));
                        temp = biggerChildren;
                    }
                }
            }
        }

    </script>
    <!-- Chart js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.0.1/chart.umd.js"
        integrity="sha512-7DgGWBKHddtgZ9Cgu8aGfJXvgcVv4SWSESomRtghob4k4orCBUTSRQ4s5SaC2Rz+OptMqNk0aHHsaUBk6fzIXw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Bootstrap - JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
</body>

</html>
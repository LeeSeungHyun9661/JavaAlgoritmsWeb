
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">About Sorting Algorithm</h1>
</div>
<ul>
    <li>
        <strong>Introduction to Sorting Algorithms:</strong>
        <br>
        <p>Sorting algorithms are foundational tools in computer science, enabling the efficient organization of data in various applications. At their core, sorting algorithms aim to rearrange elements in a list or array in a specific order, such as ascending or descending, based on certain criteria. The importance of sorting algorithms extends beyond simple data organization; they are essential for tasks like searching, data analysis, and computational problem-solving. Understanding the different types of sorting algorithms and their characteristics is key to selecting the most appropriate algorithm for a given problem and optimizing computational efficiency.</p>
    </li>
    <li>
        <strong>Comparison of Sorting Algorithms:</strong>
        <br>
        <p>Comparing sorting algorithms involves analyzing their performance characteristics, including time complexity, space complexity, stability, and adaptability to different datasets. While some algorithms like bubble sort and selection sort are simple to implement, they may be inefficient for large datasets due to their quadratic time complexity. In contrast, more advanced algorithms like merge sort and quicksort offer better average-case performance with O(n log n) time complexity, making them suitable for larger datasets. However, the choice of algorithm depends on various factors such as the size and nature of the dataset, available resources, and desired stability.</p>
    </li>
    <li>
        <strong>Real-World Applications of Sorting Algorithms:</strong>
        <br>
        <p>Sorting algorithms find applications in a wide range of real-world scenarios, from organizing data in databases and optimizing search operations to facilitating efficient file management on computers. For example, databases use sorting algorithms to quickly retrieve and display sorted query results, improving user experience and system performance. Similarly, operating systems rely on sorting algorithms to efficiently manage files and directories, enabling users to navigate and access data with ease. Understanding sorting algorithms is crucial for developers and engineers working on systems that handle large volumes of data and require fast and efficient sorting capabilities.</p>
    </li>
    <li>
        <strong>Optimizing Sorting Algorithms:</strong>
        <br>
        <p>Optimizing sorting algorithms involves improving their efficiency and performance through various techniques, such as parallel processing, hybrid approaches, and specialized optimizations for specific types of data. For example, parallelizing sorting algorithms can leverage multiple processors or cores to sort data concurrently, reducing overall execution time. Hybrid approaches combine the strengths of different algorithms to achieve better performance in specific scenarios, such as using insertion sort for small sublists in merge sort. Specialized optimizations, such as radix sort for integer data or counting sort for limited range values, can further improve efficiency by exploiting specific characteristics of the data being sorted.</p>
    </li>

    <li>
        <strong>Sorting Algorithms in Data Structures:</strong>
        <br>
        <p>Sorting algorithms are closely integrated with various data structures, shaping their design and functionality. For instance, arrays and linked lists often use sorting algorithms to arrange elements in a specific order, facilitating efficient search and retrieval operations. Trees and graphs may employ sorting algorithms to organize nodes or edges based on certain criteria, enabling traversal and manipulation of hierarchical data structures. Understanding how sorting algorithms interact with different data structures is essential for designing efficient algorithms and data storage solutions in computer science and software engineering.</p>
    </li>

    <li>
        <strong>Sorting Algorithms in Competitive Programming:</strong>
        <br>
        <p>In competitive programming contests, sorting algorithms play a crucial role in solving algorithmic problems efficiently within strict time and memory constraints. Competitors must select the most appropriate sorting algorithm for each problem based on its requirements and input size. Strategies may involve leveraging the inherent properties of certain algorithms, such as merge sort's stability or quicksort's average-case performance, to optimize solutions and maximize competitive rankings. Mastery of sorting algorithms is a cornerstone of success in competitive programming, enabling competitors to tackle diverse problems effectively and achieve optimal solutions within limited timeframes.</p>
    </li>

    <li>
        <strong>Emerging Trends in Sorting Algorithms:</strong>
        <br>
        <p>Recent developments and emerging trends in sorting algorithms reflect advancements in computational techniques, hardware architectures, and problem-solving methodologies. For example, machine learning-based approaches aim to leverage data-driven models and algorithms to optimize sorting processes and adapt to dynamic data distributions. Quantum sorting algorithms explore the potential of quantum computing to revolutionize sorting efficiency by exploiting quantum phenomena such as superposition and entanglement. Additionally, optimizations tailored to specific hardware architectures, such as GPUs or specialized accelerators, seek to further enhance sorting performance and scalability in modern computing environments. Keeping abreast of these emerging trends is essential for researchers and practitioners seeking to push the boundaries of sorting algorithm efficiency and applicability in diverse domains.</p>
    </li>
</ul>

<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">Algorithm Examples</h1>
</div>
<p>
<ol>
    <li>
        <strong>Bubble Sort</strong>: A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. Despite its simplicity, it has poor time complexity (O(n^2)) and is typically used for educational purposes rather than in practical applications.
    </li>
    <li>
        <strong>Selection Sort</strong>: Another simple comparison-based algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist. It repeatedly selects the smallest (or largest) element from the unsorted sublist and moves it to the end of the sorted sublist. Selection sort also has a time complexity of O(n^2) and is generally not suitable for large datasets.
    </li>
    <li>
        <strong>Insertion Sort</strong>: Similar to how people sort a deck of cards, insertion sort builds the final sorted array one element at a time. It iterates through the input list, removing one element at a time and inserting it into its correct position in the sorted portion of the list. While insertion sort is more efficient than bubble sort and selection sort, it still has a time complexity of O(n^2) in the worst case.
    </li>
    <li>
        <strong>Merge Sort</strong>: A divide-and-conquer algorithm that recursively divides the input list into smaller sublists until each sublist contains only one element. It then merges the sublists back together, sorting them in the process. Merge sort has a time complexity of O(n log n) in all cases, making it more efficient than the previous algorithms for large datasets.
    </li>
    <li>
        <strong>Quicksort</strong>: Another divide-and-conquer algorithm that selects a pivot element from the list and partitions the other elements into two sublists based on whether they are less than or greater than the pivot. It then recursively sorts the sublists. Quicksort is generally faster than merge sort for small datasets and has an average time complexity of O(n log n), although it can degrade to O(n^2) in the worst case.
    </li>
    <li></li>
    <li></li>
    <li></li>

</ol>
</p>
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">Java Code for Algorithm</h1>
</div>


<div class="card card-body">
    <pre class="line-numbers">
        <code class="language-java">package main;
        
        import java.util.ArrayList;
        import java.util.Collections;
        import java.util.Random;
        import java.util.Scanner;
        
        import sortings.*;
        
        public class Main {
            public static void main(String[] args) {
                // Input for choice the Sorting option
                Scanner input = new Scanner(System.in);
                boolean exit = true;
        
                // This while loop repeats until the 'exit' value is set to 0.
                while (exit) {
                    // This 'generateArr' function creates an ArrayList with random integers without
                    // duplicates.
                    ArrayList<Integer> list = generateArr(100);
                    // This 'answer' list just to make sure it's correct.
                    ArrayList<Integer> answer = list;
                    Collections.sort(answer);
        
                    // Each of Case in this 'switch loop' return sorted ArrayList
                    System.out.print("Select Sorting! : ");
                    switch (input.nextInt()) {
                    case 0: {
                        exit = false;
                        break;
                    }
                    case 1: {
                        System.out.println("Bubble Sorting! :");
                        show(new BubbleSort(list));
                        break;
                    }
                    case 2: {
                        System.out.println("Selection Sorting! :");
                        show(new SelectionSort(list));
                        break;
                    }
        
                    case 3: {
                        System.out.println("Double Selection Sorting! :");
                        show(new DoubleSelectionSort(list));
                        break;
                    }
                    case 4: {
                        System.out.println("Insertion Sorting! :");
                        show(new InsertionSort(list));
                        break;
                    }
        
                    case 5: {
                        System.out.println("Merge Sorting! :");
                        show(new MergeSort(list));
                        break;
                    }
        
                    case 6: {
                        System.out.println("Quick Sorting! :");
                        show(new QuickSort(list));
                        break;
                    }
        
                    default:
                        System.out.println("Worng Input!!");
                        break;
                    }
        
                    if (answer.toString().equals(list.toString())) {
                        System.out.println("______________________correct____________");
                    } else {
                        System.out.println("____________________Incorrect____________");
                        System.out.println(answer.toString());
                        System.out.println(list.toString());
                    }
        
                }
            }
        
            // This function creates an array of random, non-duplicate integers.
            private static ArrayList<Integer> generateArr(int size) {
                Random rand = new Random();
                ArrayList<Integer> list = new ArrayList<>();
                while (list.size() < size) {
                    int randInt = rand.nextInt(1000);
                    // The way to remove duplicates is to check if a certain value exists in an
                    // existing array.
                    if (!list.contains(randInt))
                        list.add(randInt);
                }
                return list;
            }
        
            private static void show(Sort sort) {
                System.out.print("Before : ");
                System.out.println(sort);
                sort.sort();
                System.out.println("");
                System.out.print("After : ");
                System.out.println(sort);
        
            }
        }            
        </code>
    </pre>
</div>

<div class="card card-body">
    <pre class="line-numbers">
        <code class="language-java">package sortings;

        import java.util.ArrayList;
        
        // Parents class to create sorting algorithms
        public abstract class Sort {
            private ArrayList<Integer> list;
            private int size;
        
            public Sort(ArrayList<Integer> list) {
                this.list = list;
                this.size = list.size();
            }
        
            public ArrayList<Integer> getList() {
                return list;
            }
        
            public void setList(ArrayList<Integer> list) {
                this.list = list;
            }
        
            public int getSize() {
                return size;
            }
        
            public abstract void sort();
        
            public String toString() {
                return list.toString();
            }
        
            public void swap(int i, int j) {
                int tmp = list.get(j);
                list.set(j, list.get(i));
                list.set(i, tmp);
            }
        
        }</code>
    </pre>
</div>
    
<!-- Prism JS -->
<script src="../resources/js/prism.js"></script>



